📊 동시성 이슈 분석 및 해결 보고서

동시성 이슈란, **하나의 자원에 두 개 이상의 요청(프로세스)이 접근하여 수정**하려고 시도할때 발생할 수 있는 데이터 불일치 문제이다.
이번 과제에서 현 ecommerce 형상의 예상되는 동시성 문제는 무엇이고, 해결 전과 해결 후를 비교하여 예상되는 동시성 문제는 있었는지, 해결 후 얼마나 개선되었는지 알아보고자 한다.
---

## 1. 발생 가능성이 있는 동시성 이슈
### 현재 구조의 문제점
1️⃣ 포인트 충전/차감 로직
- 사용자가 동시에 요청시 마지막 요청 금액으로 update 될 가능성이 있다.
- 동시에 충전시
```
initial : 1000원
Tx-1: charge 1000원, Tx-2: charge 500원
Tx-1: 1000+1000 , Tx-2: 1000+500

Result: 1500원
```
- 동시에 사용시
```
initial : 1000원
Tx-1: use 1000원, Tx-2: 500원
Tx-1: 0원, Tx-2: 500원

Result: 500원 
```

2️⃣ 재고 차감
- 여러 유저가 동시에 하나의 상품 재고 차감시 **마지막 유저가 차감한 기록**으로 업데이트 될 수 있다.
- select 후, 해당 data row에서 pk를 기준으로 재고를 차감하기 때문에 음수가 될 수는 없다고 생각한다. (도메인에서 음수가 되었을 때 실패 로직이 존재한다면)

3️⃣ 주문/결제
- **재고 차감 -> 포인트 차감 -> 주문 생성** 의 순서로 로직을 타다보니, 이 3step 중 하나라도 실패하면 전체 실패가 되도록 OrderFacade클래스의 createOrder 메서드에 `@Transcational`를 달아두어서 트랜잭션의 범위가 넓다.
- 트랜잭션의 범위가 넓다면 락 대기시간이 길어져 성능 저하로 이어질 수 있다.

❓ 쿠폰 사용/취소 로직
현재 형상으로는 쿠폰 로직에서 문제 발생 여지가 매우 적다고 생각한다.
문제가 생길 수 있다면, 사용을 연속으로 호출하거나 취소를 연속으로 호출할때 발생하지만 아래의 시나리오 때문에 그럴 가능성이 매우 적다.


쿠폰 발급, 사용, 취소 시나리오를 보면,
- 주문서 작성 페이지에서 적용 가능한 쿠폰의 list를 조회하고, **쿠폰 사용 API를 먼저 처리**한다.
- 유저가 아직 주문 처리를 하지않고 새로운 브라우저를 켜서 또 다른 상품의 주문서 작성 페이지로 넘어가면 적용 가능한 쿠폰의 list를 조회했을때 앞에서 적용한 쿠폰은 보이지 않게 하기 위함이다.
- 이때 사용한 couponId를 주문/생성 api Request 필드에 적용해준다.
- 주문/결제 로직에서는 해당 couponId를 보고 주문 기록, 할인 금액 차감 등의 행위를 한다.
- 주문/결제 실패시, 쿠폰 취소 로직을 비동기로 호출한다.


쿠폰 발급, 사용, 취소 로직은 모두 **MAP_USER_COUPON 테이블**에 접근한다.
- COUPON 테이블에 쿠폰을 저장하고 삭제하는 로직은 admin성이 강하다. 때문에 API는 따로 만들지 않았고 테스트 데이터로 대체했다.
- MAP_USER_COUPON 테이블은 하나의 유저가 여러 쿠폰을 가질 수 있고, 하나의 쿠폰은 여러 여러 유저가 발급받을 수 있다. N:M 관계이기 때문에 카디널리티를 줄이기 위한 유저 <-> 쿠폰 매핑 테이블이다. PK(userId, couponId) 이기 때문에 애초에 유저는 한 쿠폰을 중복 발급 받아 가질 수 없다. (Domain에서 중복 발급하려고 할 때 에러처리는 해두었음!)
- 쿠폰 발급은 MAP_USER_COUPON 테이블에 INSERT, 쿠폰 사용, 취소는 MAP_USER_COUPON 테이블의 UPDATE이다. -> 사용과 취소는 쿠폰의 couponState 컬럼만 update해서 동시성 문제가 있을 수 있지만 주문/결제 라는 간극이 있어 둘 사이에 동시성 문제가 생기기는 어렵다.
- 문제가 되는 것은 **연속 사용, 연속 취소** 로 보인다.


## 2. Database 락을 사용한 문제 해결
- DML을 통해 발생할 수 있는 동시성 문제를 해결하기 위해 DB는 Exclusive-lock과 Shared-lock이라는 개념이 있다. 해당 Lock은 row-lock이다.
- 보통 x-lock(Exclusive-lock), s-lock(Shared-lock)으로 표현하며 x-lock의 경우 읽기, 쓰기 모두 잠금, s-lock의 경우 읽기는 공유 가능하다.
- 기본적으로 이 두가지의 Lock을 통해 DB의 격리레벨 개념이 시작된다.
- 이때 가장 중요한 MVCC(Multi Version Concurrenty Control)가 있다. 이 개념은 여러 버전의 Date row가 된다는 점에서 다양한 버전이라고 말한다. update 전의 데이터를 Undo log에 기록하면서 update전의 데이터를 select할 수 있다.
- lock이라는 개념은 Undo Log에는 적용되지 않는다. 때문에 INSERT에서 동시성 이슈가 발생되지 않지만, Update 로직에서 동시성 이슈가 발생할 수 있다.

## 3. Lock 전략
1️⃣ 낙관적 락(Optimistic Lock)
- 충돌이 거의 없을 것이라고 기대하는 로직에 적용한다.
- **읽는 시점에 Lock을 적용하지 않고, 쓰는 시점에 버전 충돌 여부를 확인**한다.
- 충돌이 감지되면 예외를 발생시켜 트랜잭션을 롤백시키거나 재시도해야한다.

2️⃣ 비관적 락(Pessimistic Lock)
- 충돌이 자주 발생할 것으로 기대하고 트랜잭션 시작 시점에 락을 설정하여 다른 트랜잭션의 접근을 차단한다.
- 정합성이 엄격하게 지켜져야 하는 경우 사용한다.
- 락을 유지하는 동안 다른 요청은 대기상태가 되므로, 요청이 많은 경우 데드락이나 병목 현상이 발생할 수 있다.